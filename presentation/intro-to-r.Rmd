---
title: "Intro to R (Summer 2021)"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: lumen
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#library(pacman)
#pacman::p_load(tidyverse, readxl, here, googlesheets4, magrittr, cansim, Quandl, stats, broom)
library(tidyverse)
library(here)
library(readxl)
library(googlesheets4)
library(magrittr)
library(cansim)
library(Quandl)
library(stats)
library(broom)
library(readstata13)
```

The main objective of this R bootcamp is to introduce R programming to incoming MFRE students. The content of this bootcamp was adapted from [Software Carpentry](https://datacarpentry.org/r-socialsci/), Dr. Nick Huntington-Klein's Teaching Econometrics with R [slides](https://rpubs.com/NickCHK/RTeach2020), and the [Open Case Studies](https://www.opencasestudies.org/ocs-bp-co2-emissions/#Data_Analysis). If you spot any errors or issues, please email krisha.lim[at]ubc.ca. 

# Before we get started

  * Familiarize yourself with the RStudio IDE
  * Understand the benefits of a project-oriented workflow. Read Jenny Bryan's post on why you should not start your scripts with `setwd()` and `rm(list = ls())` [here](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/). 

#  Packages

There are thousands of packages (bundles of codes) available on [CRAN](https://cran.r-project.org/). If you are struggling to accomplish a certain task, it is very likely that someone has already created a function or a package to do it for you. 

To install a package, use the command `install.package("package_name")` - do not forget the quotation marks! To install multiple packages at once, you can use the code `install.packages(c("package_1", "package_2", ...))`. 

A big difference between R and Stata is that you have to load the package you will (or plan to use) use every time you start a new R session. To load a package, use the command `library(package_name)` - the quotation marks are now optional. You can write a function to load multiple libraries at once.

The `pacman` package allows you to install and load packages in R more efficiently. The function `p_load()` checks whether a package is already installed, and if not, installs the package and loads it. The function can also be applied to several package at once, so you save a few (or many) lines of codes. 

```{r pacman_norun, eval = FALSE}
# install.packages("pacman")
pacman::p_load(tidyverse, readxl, googlesheets4, readstata13, magrittr, cansim, Quandl, stats, broom, modelsummary)
```
 
```{r pacman_run, echo = FALSE}
pacman::p_load(tidyverse, readxl, googlesheets4, readstata13, magrittr, cansim, Quandl, stats, broom, modelsummary)
```

# R Basics 

By the end of this section, students will be able to

* create, name, and assign values to objects
* use comments to inform script
* inspect, manipulate, and subset vectors, lists, and dataframes/tibbles
* call functions and use arguments to change default options
* deal with missing values in objects

## Interacting with R 

We can get output from R console by typing math expressions. 

```{r, eval = FALSE}
1+1 
2+4*1^3
100 %/% 60 
100 %% 60
```

We can also get output from R by typing logic statements in the console.

```{r logicstmts, eval = FALSE}
1 > 2 & 1 > 0.5 # The "&" stands for "and"
1 >2 | 1 > 0.5 # The "|" stands for "or"
3 + 4 == 4 + 3 # The "==" stands for "equal to"
3 + 4 != 4 + 3 # The "!" is negation
```

To do useful things, we assign values to objects. `<-` is the assignment operator in R. Objects are one of the main differences of R with Stata. 

To create an object, the syntax is `object_name <- value`. When assigning values to an object, R does not automatically print the object; you will have to print this object to see the value or output. 

It is also smart to comment on your code. In R, the `#` symbol indicates the start of the comment. 

```{r}
x <- 3 
x # prints the value of x
x <- 10
x # we can also overwrite the value of an existing object
```

## Data object types

There are different types of objects in R. The common ones we will use are: numeric, character, factor, and logical. There are different functions (or commands) in R to examine objects. Common examples are `class()`, `typeof()`, `str()`, `length()`. 

```{r dataobjecttypes, eval = FALSE}
numeric_var <- 1.5
character_var <- "one"
factor_var <- factor(1, labels = "one")
logical_var <- TRUE
```

## Vectors

Multiple observations of the same type are called vectors. You use the `c()` function to concatenate values.  

For example, we can create a vector of the emissions of three countries and assign it to a new object called `emissions`. 

```{r vectors}
emissions <- c(53700, 14300, 5250000)
emissions
```

We can also create a character vector called `countries`. Quotes around the text are important to indicate the data is of the type character. If not, R will think it is an object. Since these objects don't exist in R, you will get an error. 

```{r morevectors}
countries <- c("Canada", "Kenya", "United States")
countries
``` 

You can also add values to existing vectors.
```{r addingtovec}
countries <- c(countries, "China")
countries
```

Here are some functions to inspect the content of a vector. 
```{r inspectvec}
length(countries) # inspect the number of elements in a vector
class(countries) # type/class of an object
class(emissions)

# The str() function provides the structure of an object and a preview of its elements. This function is useful when inspecting large and complex objects. 
str(emissions) 
```

Vectors must always be of the same type. If we try to mix different types (character, numeric, logical, etc.) in a vector, R will force the content to be the same. 

```{r difftypesvector}
trythis <- c(1, 2, 3, "a")
class(trythis)
```

### Subsetting Vectors

We use the index position of an element in square brackets to extract one or more elements from a vector. Note that the index starts at 1. 

```{r extract}
# to extract the first element
emissions[1]

# to extract the first and third element
emissions[c(1,3)]

# to extract the second and third element
emissions[c(2:3)]
```

We can also use logical tests to subset vectors. 

```{r extract_log}
# to select emissions greater than 100000
emissions[emissions > 100000]

# to select emissions that are greater than 0 and less than 55000
emissions[emissions > 0 & emissions < 55000]
```

We can also use `%in` to check whether an object is contained within or matches with a list of items. 

```{r extract_in}
emissions %in% c("Canada")

countries %in% c("Canada", "United States")

emissions %in% c(14300, 50000)
```

## Lists

A list is a flexible R object that is a collection of different objects. You can extract sub-objects using `[[]]` or `$`. A common example of a list object you will interact with often is regression objects (more on this later!). 

```{r list}
first_list <- list(a = 1:5, b = 6:10, c = c("food", "resource", "economics"))
first_list #print the output
class(first_list)
class(first_list$a)
class(first_list[["c"]])

first_list[["a"]] # extract elements in a using [[]]
first_list$c #extract elements in c using $ 
```

## Data Frames

In MFRE, we will work a lot with data frames. A data frame is a list composed of vectors of equal length. Data frames can story different data types in each column. For example, the first column can be a character vector, and the second column is a numeric vector. You can createa data frame object using the function `data.frame()`.

```{r df}
first_df <- data.frame(countries = c("Canada", "Kenya", "United States"),
                       emissions = c(53700, 14300, 5250000))

first_df

# class(first_df)
# extract values in country column: first_df[["countries]] or first_df$countries
```

A special type of data frame we will work with in this bootcamp is called tibbles; you can read more about it [here](https://r4ds.had.co.nz/tibbles.html). 

We can convert the `first_df` into a tibble using the `as_tibble()` function and call it `first_tibble`. We can also create a new tibble, which we will call `second_tibble` 

```{r tibble}
first_tibble <- as_tibble(first_df)
first_tibble 
class(first_tibble)
# first_tibble[["countries"]] or first_tibble$countries to extract the data in the countries column

second_tibble <- tibble(countries = c("Peru", "Mexico", "China"),
                        emissions = c(61700, 480000, 10300000))
```

## Functions

Functions are scripts that automate complicated commands. You can write your own function, or you can also use functions that are available in R packages. A function gets one or more inputs called *arguments*. Functions often, but not always, return a value. One example of a function is the `sqrt()`. If you type in `?sqrt()` in the console, you will the documentation on the lower right panel under the 'Help` tab. You learn that the input (argument) must be numeric, and running the function will return the square root of the number. 

```{r sqrt}
a <- sqrt(100)
a
```

In the example above, the value 100 is given to the `sqrt()` function. The `sqrt()` function calculates the square root, and returns the value assigned to the object `a`. 

Arguments differ per function, and you can look up the documentation using the `?function_name` command in your console. Some functions take arguments that must be specified by the user, and if not, will use a default value - these are called options. Options are ways to change how the function works. 

Let's try a function that takes multiple arguments -- `round()`. 

```{r round}
round(3.14159)
```

Here, we used the `round()` function with just one argument, `3.14159`. The function returned a value of 3. If we look at the documentation in `?round`, we see that the default option is `digits = 0` or to round up to the nearest whole number. If we want to round up to only 2 decimal places, we can type in `digits = 2`. 

```{r round_2}
round(3.14159, digits = 2)
```

If you provide the arguments in the same order as they are defined, i.e. `round(x, digits = 0)`, then you don't need to include `digits =` anymore. 

```{r round_3}
round(3.14159, 2)
``` 

You can find some built in R functions [here](https://www.statmethods.net/management/functions.html). Common ones we will use are `mean()`, `median()`, `min()`, `max()`. The code below shows you can take the mean of the emissions variable in the `first_tibble` tibble. 

```{r mean_emissions}
mean(first_tibble$emissions)
```

For these statistical functions, you will have to indicate how the function will treat missing values. In R, missing data are represented in vectors as `NA`. If you don't specify how the function will treat missing values, the function will return NA. 

Let's return to our `first_tibble` object. Let's say we want to add Peru's emissions, but we don't have the data yet. We can use the `add_row()` function to do this step. Notice that I also have a `%>%` operator there. It is called the pipe. The pipe operator allows you to express a series of operators clearly (more info [here](https://r4ds.had.co.nz/pipes.html)). It takes the output on the left of the `%>%` and pass it to the function on the right. In the code below, `first_tibble` (left of the `%>%`) is passed on to another function, which is the `add_row` function. Then we are assigning it back to `first_tibble`, overwriting our initial data. If we don't use the assignment operator `<-`, then we have not overwritten `first_tibble`

```{r tibble_addrow}
# let's first add a row with missing data in first_tibble
# no assignment operator
first_tibble %>% 
  add_row(countries = "Peru", emissions = NA)

first_tibble # Peru is not saved in first_tibble

first_tibble <- first_tibble %>% 
  add_row(countries = "Peru", emissions = NA)

first_tibble 
```

Now, let's try to take the mean of emissions. 

```{r mean_na}
mean(first_tibble$emissions)
```

Notice that you `NA` as the output. This feature makes it harder to overlook cases where you are dealing with missing data. If you take a look at the documentation (`?mean`), you can see that the default is `na.rm = FALSE`. By adding in `na.rm = TRUE`, then you are asking R to calculate the mean and that NA values should be ignored. Now the output will show `r mean(first_tibble$emissions, na.rm = T)`

```{r mean_na2}
mean(first_tibble$emissions, na.rm = T)
```

  ** Note to self: Need to add a few notes on functions in prep for FRE501. 

# Data 

By the end of this section, students will be able to 

* Load data in 5 ways
  * csv
  * xlsx
  * .dta files (Stata)
  * Google Sheet
  * API (Statistics Canada, Quandl)

## Load data  
```{r loaddata, message = FALSE, warning = FALSE}
carbon <- read_csv("../data/yearly_co2_emissions.csv")

temp <- read_csv("../data/temperature.csv", skip = 4, na = "-99")

energy_hist <- read_xlsx("../data/energy_use_per_person.xlsx", sheet = 1)
energy_recent <- read_xlsx("../data/energy_use_per_person.xlsx", sheet = 2)
energy <- full_join(energy_hist, energy_recent, by = c("country"))

politics <- read.dta13("../data/political_party.dta")

gs4_deauth() # so no need to sign in
disasters <- read_sheet("https://docs.google.com/spreadsheets/d/17s15o7jdDpGSKgsIboZdnYU2UxHtU9DHKNRmYVVgwJo/edit#gid=0", skip = 2) 


gdp <- read_xlsx("../data/gdp_per_capita_yearly_growth.xlsx")

ag <- get_cansim('32-10-0359-01')

corn <- Quandl("CHRIS/LIFFE_EMA1")

politics <- read.dta13("../data/politics.dta", nonint.factors = TRUE)
```

  ** Note to self: Need to add about how to call different datasets and variables using the `$` operator
  
## View Data

The following functions can be used to explore your dataset
```{r viewdata, eval = FALSE}
head(politics)
tail(politics)
names(politics)
dim(politics)
str(politics)
glimpse(politics)
```

Using `dplyr`

```{r}
carbon %>% 
  select(country, `2010`:`2014`) %>%
  slice_head(n = 5)

set.seed(2021)
carbon %>% 
  select(country, `2010`:`2014`) %>%
  slice_sample(n = 10)
```

## Basic data exploration

The `modelsummary` package allows you to produce very nice summary statistic plots for tidy data. You can read more [here](https://vincentarelbundock.github.io/modelsummary/articles/datasummary.html). 

```{r exploredata_cont, warning = FALSE, message = FALSE}
politics %>% group_by(region) %>% summarize(mean(v2x_libdem, na.rm = T))

datasummary_skim(politics)
```

  ** Note to self: Need to add in base R commands to prep for Dr. Vercammen's code

We need to add an argument `type = categorical` to see summary statistics for non-numeric data.
```{r exploredata_cat, warning = FALSE, message = FALSE}
datasummary_skim(politics, type = "categorical")
```

# Data Wrangling

  * Reshaping Data
  * Renaming columns
  * Changing data types
  * Creating new variables
  * Filtering observations
  * Selecting columns/variables
  * String manipulation
  * Joining/Merging datasets (need to modify to just use merge())

## Reshaping Data

```{r}
carbon_long <- carbon %>%
  pivot_longer(cols = -country,
               names_to = "Year",
               values_to = "Emissions")

head(carbon_long)

set.seed(2021)
carbon_long %>% 
  slice_sample(n = 10)

```

## Renaming columns

An alternative to using the assignment operator is `%<>%`.

```{r}
carbon_long %<>%
	rename(year = Year,
		      emissions = Emissions)

set.seed(2021)
carbon_long %>% 
  slice_sample(n = 10)
```


## Changing Data types 

```{r}
#glimpse(carbon_long)
str(carbon_long)

carbon_long %<>% mutate(year = as.numeric(year))

str(carbon_long)

```

## Creating new variables

```{r}
# create a new column that contains the average of that country's emissions 
sample <- carbon_long %>%
  group_by(country) %>%
  mutate(avg_emissions = mean(emissions, na.rm = T))

set.seed(2021)
sample %>% 
  slice_sample(n = 10)
```

## Filtering observations

```{r}
canada <- carbon_long %>% filter(country == "Canada") %>%
  drop_na(emissions)
```

## Tidying the gdp and energy data

Practice tidying the gdp data
```{r}
# glimpse(gdp)
head(gdp)
# str(gdp)

gdp_long <- gdp %>% 
  pivot_longer(cols = -country,
               names_to = "year",
               values_to = "gdp") %>%
  mutate(year = as.numeric(year))

head(gdp)
# str(gdp)

# glimpse(energy)
head(energy)

energy_long <- energy %>%
  pivot_longer(cols = -country,
               names_to = "year", 
               values_to = "energy") %>%
  mutate(year = as.numeric(year))
head(energy)
```

## Selecting columns based on text

```{r}
names(disasters)

# Overwrite the disasters dataset to only contain Year and columns with the text 'count' in them

disasters %<>% select(Year, contains("Count"))
names(disasters)

disasters %<>% rename(year = Year,
                      drought = `Drought Count`,
                      flooding = `Flooding Count`,
                      freeze = `Freeze Count`,
                      severe_storm = `Severe Storm Count`,
                      tropical_cyclone = `Tropical Cyclone Count`,
                      wildfire_count = `Wildfire Count`,
                      winter_storm = `Winter Storm Count`)
names(disasters)
```

## Creating a total count of disasters 

```{r}
# create a new variable that contains the total number of disasters per year
disasters %<>%
 mutate(total_disasters = rowSums(select(., -year)))
```

## Select only the total_disasters column and create a new variable country to indicate this data is from USA

```{r}
disasters %<>%
  mutate(country = "United States") %>%
  select(year, country, total_disasters) 

disasters %>%
  slice_head(n = 5)
```

## String manipulation

We will now clean the temperature data

```{r}
# glimpse(temp)

# If we look at the 'Date' variable of the temperature data, we see that it is 6 digits and somehow all end with 12 
# let's first check whether the length of each data entry is indeed 6
str_length(temp$Date)

# let's now check whether the last 2 characters of each Date entry is indeed 12
str_ends(temp$Date, pattern = "12")

# Now we will overwrite the Date variable to only get the first 4 digits
temp %<>% mutate(Date = str_sub(Date, start = 1, end = 4))
head(temp)
```

## Tidy temperature dataset

We will (a) drop the Anomaly variable, (b) rename Date to year, (c) make year numeric) (c) rename Value to temp, (d) add a country variable 

```{r}
temp %<>% 
  rename(temp = Value) %>%
  mutate(year = as.numeric(Date),
         country = "United States") %>%
  select(year, country, temp)

head(temp)
```

## Joining data - full join

```{r}
data <- carbon_long %>%
  full_join(gdp_long, by = c("country", "year")) %>%
  full_join(energy_long, by = c("country", "year")) 

tail(data)
# 
# data_long <- data %>%
#   pivot_longer(cols = c(-country, -year),
#                names_to = "indicator", 
#                values_to = "value")
# 
# head(data_long)
```

### Some more cleaning

```{r}
data %<>% mutate(region = case_when(country == "United States" ~ "United States",
                                    country != "United States" ~ "Rest of the World")) %>%
  drop_na()

```

## Data exploration

```{r, results = 'hide', echo = 'false'}
data %>% filter(country == "United States") %>%
  summarize(first(emissions), first(year))
```

## Joining data - left join

```{r}
usa <- carbon_long %>%
  filter(country == "United States") %>%
  left_join(gdp_long, by = c("country", "year")) %>%
  left_join(energy_long, by = c("country", "year")) %>%
  full_join(temp, by = c("country", "year")) %>%
  full_join(disasters, by = c("country", "year"))
```

# Data Visualization

## Basic R
```{r}
plot(data$year, data$emissions)
```

## ggpplot

How has carbon emissions changed over time? 
```{r}
data %>% group_by(year) %>%
  summarize(total_emissions = sum(emissions)) %>%
  ggplot(aes(x = year, y = total_emissions)) +
  geom_line(size = 1.5)
```

```{r}
data %>% group_by(year) %>%
  summarize(total_emissions = sum(emissions)) %>%
  ggplot(aes(x = year, y = total_emissions)) +
  geom_line(size = 1.5) + 
  labs(title = "World" ~CO[2]~ "Emissions",
       caption = "Limited to reporting countries only",
       y = "Emissions (metric tonnes)") +
  theme_classic()
```

Are certain countries contribute more emissions than others? 
```{r}
data %>% 
  ggplot(aes(x = year, y = emissions, group = country)) +
  geom_line(size = 1) +
  theme_classic()
```

Change the transparency of the lines due to overlapping lines
```{r}
data %>% 
  ggplot(aes(x = year, y = emissions, group = country)) +
  geom_line(size = 1, 
            alpha = 0.4) +
  theme_classic()
```

Compare USA to the rest of the world
```{r}
data %>% 
  ggplot(aes(x = year, y = emissions, group = country, color = region)) +
  geom_line(size = 1) +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic()
```

## Visualize carbon emissions over the years for the top 10 countries with the highest emissions in 2014

```{r}
# Create a new object to identify the 10 countries with highest emissions in 2014
top10countries <- data %>%
  filter(year == 2014) %>%
  mutate(rank = dense_rank(desc(emissions))) %>%
  filter(rank <= 10) %>%
  arrange(rank)

# filter original data for countries in top10
top10data <- data %>%
  filter(country %in% pull(top10countries, country)) 

ggplot(top10data, aes(x = year, y = emissions, color = country)) + 
  geom_line() + 
  theme_classic()
```

# Data Analysis

By the end of this section, the students will be able to:

* Calculate basic summary statistics
* Run hypothesis tests
* Run regressions
* Format regression results

## Summary Statistics
```{r}
usa %>% summarise(mean_emissions = mean(emissions, na.rm = T), 
                  mean_temp = mean(temp, na.rm = T),
                  sd_emissions = sd(emissions, na.rm = T),
                  sd_temp = sd(temp, na.rm = T))
```

## Correlation
```{r}

usa <- usa %>% drop_na()

usa %>%
  summarize(r = cor(x = emissions,
                    y = temp,
                    method = "pearson")) %>%
  pull(r)

cortest <- cor.test(pull(usa, emissions), 
                    pull(usa, temp))

# see the structure of the data
# str(cortest)
cortest$statistic
cortest$p.value
# tidy the results
tidy(cortest)
```

```{r testonly}
politics %<>% rename(country = country_name)
data2 <- data %>% full_join(politics, by =c("country", "year"))
data2$gdp2 <- data2$gdp * data2$gdp
```

## Regressions
```{r}
# run the regression

reg1 <- lm(emissions ~ gdp, data = usa)
# stargazer(reg1, type = 'html')
summary(reg1)

reg2 <- lm(emissions ~ log(energy) + gdp + gdp2 +v2x_libdem, data = data2)
summary(reg2)
```

```{r}
sum(residuals(reg2)^2)
anova(reg2)
```
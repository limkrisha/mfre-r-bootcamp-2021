---
title: "Intro to R (Summer 2021)"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: lumen
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(readxl)
library(googlesheets4)
library(magrittr)
library(cansim)
library(stats)
library(broom)
library(readstata13)
```

The main objective of this R bootcamp is to introduce R programming to incoming MFRE students. The content of this session is adapted from [Software Carpentry](https://datacarpentry.org/r-socialsci/) and Dr. Nick Huntington-Klein's Teaching Econometrics with R [slides](https://rpubs.com/NickCHK/RTeach2020). If you spot any errors or issues, please send me a message on Canvas or at krisha.lim[at]ubc.ca. 

# Before we get started

* Programming in R is one of the tools taught in the MFRE program to support econometrics, economics, and business analysis applications. 
* R is the language. RStudio is the IDE. If I say let's use R, I mean let's run R using RStudio. 
* Stay organized. It is good to have one working directory per project. You can check for the working directory using the `getwd()` command. The best practice is to use R projects and the `{here}` package. 
  * The `{here}` package will determine the top-level of your current project, which is your working directory. In my case it is "H:/Workshops/2021-r-bootcamp". The `here()` function allows me to build the path relative to this directory. So instead of typing "H:/Workshops/2021-r-bootcamp/data/emissions.csv" to refer to the emissions.csv file saved in the data folder (or "data/emission.csv" if I set the working directory), I can use `here("data", "emissions.csv")`.  
  * I discourage you from using`setwd("insert_file_path_here")` because this file path will only work on your computer. Read more about this issue [here](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/). 


# Packages

There are thousands of packages (bundles of codes) available on [CRAN](https://cran.r-project.org/). If you are struggling to accomplish a certain task, it is very likely that someone has already created a function or a package to do it for you. 

To install a package, use the command `install.package("package_name")`. Do not forget the quotation marks! To install multiple packages at once, you can use the code `install.packages(c("package_1", "package_2", ...))`. 

A big difference between R and Stata is that you have to load the package you will (or plan to use) use every time you start a new R session. To load a package, use the command `library(package_name)`. The quotation marks are now optional. You can also write a function to load multiple libraries at once.

Sometimes, you may encounter the code `require(package_name)`. Like `library(package_name)`, it will load the already installed package. The main difference between `require()` and `library()` is that `library()` returns an error if the package you are calling is not yet installed, whereas `require()` will return only a warning. More info on the difference [here](https://www.r-bloggers.com/2016/12/difference-between-library-and-require-in-r/#:~:text=The%20require()%20is%20designed,if%20the%20package%20is%20loaded.&text=It%20is%20better%20to%20use,during%20the%20package%20loading%20time). 

The `pacman` package allows you to install and load packages in R more efficiently. The function `p_load()` checks whether a package is already installed, and if not, installs the package and loads it. The function can also be applied to several package at once, so you save a few (or many) lines of codes. 

Let's now load the packages we will use for the rest of the bootcamp! 

```{r pacman_norun, eval = FALSE}
install.packages("pacman")
library(pacman)
# require(pacman)
p_load(tidyverse, readxl, googlesheets4, readstata13, magrittr, cansim, stats, broom, modelsummary, flextable, here)
```
 
```{r pacman_run, echo = FALSE}
pacman::p_load(tidyverse, readxl, googlesheets4, readstata13, magrittr, cansim, stats, broom, modelsummary, flextable, here)
```

# Interacting with R 

We can get output from R console by typing math expressions. 

```{r, eval = FALSE}
1 + 1 
2 + 4 * 1^3
100 %/% 60 # How many whole hours in 100 minutes?
100 %% 60 # How many minutes are left over?
```

We can also get output from R by typing logic statements in the console.

```{r logicstmts, eval = FALSE}
1 > 2 & 1 > 0.5 # The "&" stands for "and"
1 >2 | 1 > 0.5 # The "|" stands for "or"
3 + 4 == 4 + 3 # The "==" stands for "equal to"
3 + 4 != 4 + 3 # The "!" is negation
```

To do useful things, we assign values to objects. `<-` is the assignment operator in R. Objects are one of the main differences of R with Stata. 

To create an object, the syntax is `object_name <- value`. When assigning values to an object, R does not automatically print the object; you will have to print this object to see the value or output. 

It is also smart to comment on your code. In R, the `#` symbol indicates the start of the comment. 

```{r}
x <- 3 
x # prints the value of x
x <- 10
x # we can also overwrite the value of an existing object
```

# Data object types

There are different types of objects in R. The common ones we will use are: numeric, character, factor, and logical. There are different functions (or commands) in R to examine objects. Common examples are `class()`, `typeof()`, `str()`, `length()`. 

```{r dataobjecttypes, eval = FALSE}
numeric_var <- 1.5
character_var <- "one"
factor_var <- factor(1, labels = "one")
logical_var <- TRUE
```

# Vectors

Multiple observations of the same type are called vectors. You use the `c()` function to concatenate values.  

For example, we can create a vector of the emissions of three countries and assign it to a new object called `emissions`. 

```{r vectors}
emissions <- c(53700, 14300, 5250000)
emissions
```

We can also create a character vector called `countries`. Quotes around the text are important to indicate the data is of the type character. If not, R will think it is an object. Since these objects don't exist in R, you will get an error. 

```{r morevectors}
countries <- c("Canada", "Kenya", "United States")
countries
``` 

You can also add values to existing vectors.
```{r addingtovec}
countries <- c(countries, "China")
countries
```
Here are some functions to inspect the content of a vector. 

  * `length()` to inspect the number of elements in a vector
  * `class()` to inspect the type or class of an object
  * `str()` to inspect the structure of an object and see a preview of its elements, which is useful when working with large and complex objects
  
```{r inspectvec_length}
length(countries)
class(countries) 
str(emissions) 
```
  
Vectors must always be of the same type. If we try to mix different types (character, numeric, logical, etc.) in a vector, R will force the content to be the same. 

```{r difftypesvector}
trythis <- c(1, 2, 3, "a")
class(trythis)
```

You can also convert one data type to another. You may find these functions useful when you load numeric data but R reads it as character. 

```{r convervectortype}
emissions <- as.character(emissions) 
class(emissions)

emissions <- as.numeric(emissions) 
class(emissions)
```

## Subsetting Vectors

We use the index position of an element in square brackets to extract one or more elements from a vector. Note that the index starts at 1. 

```{r extract}
# to extract the first element
emissions[1]

# to extract the first and third element
emissions[c(1,3)]

# to extract the second and third element
emissions[c(2:3)]
```

We can also use logical tests to subset vectors. 

```{r extract_log}
# to select emissions greater than 100000
emissions[emissions > 100000]

# to select emissions that are greater than 0 and less than 55000
emissions[emissions > 0 & emissions < 55000]
```

We can also use `%in%` to check whether an object is contained within or matches with a list of items. 

```{r extract_in}
emissions %in% c("Canada")

countries %in% c("Canada", "United States")

emissions %in% c(14300, 50000)
```

# Matrices

So far we have looked at one-dimensional objects. Matrices are two-dimensional objects in R and another common R object you will work with. Elements must be of the same data type and are arranged in rows and columns.

You can construct a matrix using the `matrix()` function.

```{r matrix}
# the 2 vectors must be of the same size length
countries <- c("Canada", "Kenya", "United States")

# Creates a matrix and assigns it to object m
m <- matrix(c(emissions, countries), nrow = 3)
m
class(m)
```

The `nrow = 3` argument tells R that your matrix has 3 rows. If you don't specify `nrow = 3`, then it will just create 1 column with the number of rows equal to the number of elements of your vectors. 

```{r matrix_nrow}
m_1 <- matrix(c(emissions, countries))
m_1
```

If you specify `nrow = 5` for example, your object will have 5 rows, and the values of some elements will repeat. 
```{r matrix_nrow5}
m_5 <- matrix(c(emissions, countries), nrow = 5)
m_5
```

You can also add column and rownames to your matrix using the `colnames()` and `rownames()` functions, respectively

```{r matrix_colnames}
colnames(m) <- c("emissions", "year")
rownames(m) <- c("c1", "c2", "c3")
m
```

You can also construct a matrix using the `cbind()` function. In FRE501, Dr. Vercammen uses this function to construct a matrix.
  
```{r matrix_cbind}
matrix <- cbind(emissions, countries)
matrix
class(matrix)
```

If you use the `cbind()` function to create a matrix, the columns in the matrix takes the names of the R objects. You can also change the column and row names using the `colnames()` and `rownames()` functions. If you want to change a specific column (or row) number, you can specify the index number in brackets. 

```{r matrix_changecol}
# change name of the first column 
colnames(matrix)[1] <- "emissions_new"

# add row names
rownames(matrix) <- c("c1", "c2", "c3")

# print column and names only
colnames(matrix)
rownames(matrix)

# dimension of the matrix
dim(matrix) # 3 rows and 2 columns
```

Just like vectors, we use brackets to subset matrices. Because matrices are two dimensional objects (rows and columns) while vectors are only one dimensional, we now need to indicate the row and column positions of the values we want to extract. The sytax would be `matrix[row_position, column_position]`. If you leave row position blank, R assumes that you are asking for the whole row. 

```{r matrix_indexing}
# extract first element of the second column
matrix[1,2]

# extract first row
matrix[1,]

# extract first row by row name - don't forget the comma after
matrix["c2",]

# extract first column 
matrix[,1]

# extract by column name - don't forget the comma in front!
matrix[, c("emissions_new")]

# extract first two rows of the first column
matrix[1:2, 1]
```

You will get an error if you combine two vectors of different size.

```{r matrix_diffsize}
countries <- c(countries, "China")

will_not_work <- cbind(emissions, countries)
```

You will also get an error if you attempt to create a matrix using 2 vectors of different types (i.e. one is numeric and another is character).

```{r matrix_error}
emission_type <- c("carbon dioxide", "carbon dioxide")

will_not_work_too <- cbind(emissions, emission_type)
```

## Lists

A list is a flexible R object that is a collection of different objects.

```{r list}
first_list <- list(a = 1:5, b = 6:10, c = c("food", "resource", "economics"))
first_list 
str(first_list)
```

You can extract sub-objects using `[]` or `[[]]` or `$`. A common example of a list object you will interact with often is regression objects (more on this later!). 

```{r list_extract}
first_list["a"] # output is a list
first_list[["a"]] # output is character vector
first_list$c #output is character vector
```

# Data Frames

In MFRE, we will work a lot with data frames. A data frame is a list composed of vectors of equal length. You can think of a data frame as an Excel spreadsheet that contains columns of different data types, and all columns have the same number of rows. Data frames can store different data types in each column. For example, the first column can be a character vector, and the second column is a numeric vector. 

You can create a data frame object using the function `data.frame()`.

```{r df}
first_df <- data.frame(countries = c("Canada", "Kenya", "United States"),
                       emissions = c(53700, 14300, 5250000))

first_df
```

We can also convert the matrix we created earlier into a data frame using the `as.data.frame()` function.

```{r matrix_df}
matrix_df <- as.data.frame(matrix)
```

Here are some functions to inspect the elements of a data frame. 
  * `dim()` to know the dimension of a data frame (can also be used in a matrix)
  * `str()` to know the structure of a data frame
  * `head()` and `tail()` to view the first or last 5 rows of the data frame 
  * `names()` to know the column names of a data frame
  
```{r df_inspect}
dim(first_df)
str(first_df)
head(first_df) 
names(first_df)
```

We can extract elements inside the data frame using `[]`, `[[]]`, and `$`. 

```{r df_extract}
first_df["countries"] #output is a data frame
first_df[["countries"]] #output is a character vector
first_df$countries #output is a character vector 
```

## Tibbles

A special type of data frame you may encounter is tibbles. You can read more about it [here](https://r4ds.had.co.nz/tibbles.html). 

We can convert the `first_df` into a tibble using the `as_tibble()` function and call it `first_tibble`. We can also create a new tibble, which we will call `second_tibble` 

```{r tibble}
first_tibble <- as_tibble(first_df)
first_tibble 
class(first_tibble)

second_tibble <- tibble(countries = c("Peru", "Mexico", "China"),
                        emissions = c(61700, 480000, 10300000))
```

# Functions

Functions are scripts that automate complicated commands. You can write your own function, or you can also use functions that are available in R packages. A function gets one or more inputs called *arguments*. Functions often, but not always, return a value. One example of a function is the `sqrt()`. If you type in `?sqrt()` in the console, you will the documentation on the lower right panel under the 'Help` tab. You learn that the input (argument) must be numeric, and running the function will return the square root of the number. 

```{r sqrt}
a <- sqrt(100)
a
```

In the example above, the value 100 is given to the `sqrt()` function. The `sqrt()` function calculates the square root, and returns the value assigned to the object `a`. 

Arguments differ per function, and you can look up the documentation using the `?function_name` command in your console. Some functions take arguments that must be specified by the user, and if not, will use a default value - these are called options. Options are ways to change how the function works. 

Let's try a function that takes multiple arguments -- `round()`. 

```{r round}
round(3.14159)
```

Here, we used the `round()` function with just one argument, `3.14159`. The function returned a value of 3. If we look at the documentation in `?round`, we see that the default option is `digits = 0` or to round up to the nearest whole number. If we want to round up to only 2 decimal places, we can type in `digits = 2`. 

```{r round_2}
round(3.14159, digits = 2)
```

If you provide the arguments in the same order as they are defined, i.e. `round(x, digits = 0)`, then you don't need to include `digits =` anymore. 

```{r round_3}
round(3.14159, 2)
``` 

You can find some built in R functions [here](https://www.statmethods.net/management/functions.html). Common ones we will use are `summary()`, `mean()`, `median()`, `min()`, `max()`. The code below shows you can take the mean of the emissions variable in the `first_df` data frame.  

```{r mean_emissions}
mean(first_df$emissions)
```

For these statistical functions, you will have to indicate how the function will treat missing values. In R, missing data are represented in vectors as `NA`. If you don't specify how the function will treat missing values, the function will return NA. 

Let's return to our `first_df` object. Let's say we want to add Peru's emissions, but we don't have the data yet. We can use the `add_row()` function to do this step. Notice that I also have a `%>%` operator there. It is called the pipe operator. The pipe operator allows you to express a series of operators clearly (more info [here](https://r4ds.had.co.nz/pipes.html)). It takes the output on the left of the `%>%` and pass it to the function on the right. In the code below, `first_df` (left of the `%>%`) is passed on to another function, which is the `add_row` function. Then we are assigning it back to `first_df`, overwriting our initial data. If we don't use the assignment operator `<-`, then we have not overwritten `first_df` and Peru will not appear when we print `first_df`. 

```{r df_addrow}
first_df %>% 
  add_row(countries = "Peru", emissions = NA)

# Since we did not use an assignment operator, Peru is not saved in first_df
first_df

first_df <- first_df %>% 
  add_row(countries = "Peru", emissions = NA)

first_df 
```

Now, let's try to take the mean of emissions. 

```{r mean_na}
mean(first_df$emissions)
```

Notice that you `NA` as the output. This feature makes it harder to overlook cases where you are dealing with missing data. If you take a look at the documentation (`?mean`), you can see that the default is `na.rm = FALSE`. By adding in `na.rm = TRUE`, then you are asking R to calculate the mean and that NA values should be ignored. Now the output will show `r mean(first_df$emissions, na.rm = T)`

```{r mean_na2}
mean(first_df$emissions, na.rm = T)
```

## Writing your own functions

Sometimes, you will find it useful to write your own functions to automate certain tasks and to reuse them later on. Read more about how to write your own functions [here](http://environmentalcomputing.net/writing-simple-functions/). If you find yourself repeating the same steps (in your current or across multiple scripts), writing a function may help you save time and also avoid mistakes. 

The syntax of a function is 

```{r intro_function, eval = FALSE}
function_name <- function(arg1, arg2, ...){
  statements # do something interesting
  object # return value
}
```

  * The `function_name` is the name you will provide to the function. You can call it anything you want, as long as it is not a keyword in R. Also, provide a meaningful name, such as a short description of the function. It is best not to call it `f1` or `func1`. 

  * The `arg1, arg2,...` are the arguments of the function. A function can have multiple arguments and can take in different data types. 

  * The code between the `{}` contains the body of the function, and will contain the code that will run everytime you call `function_name`. 

  * The `object` is the value to be returned by the function. Some people may write `return(object)` or `object` or do not specify. 

Let's take a look at an example. R does not have a built in function to calculate standard error. Recall that the formula of the standard error is $SE =  \sqrt{var/ n}$

Let's say we want to calculate the standard error for emissions.

```{r se_emissions}
sqrt(var(first_df$emissions, na.rm = T) / length(first_df$emissions))
```

Not too bad! But what if you want to calculate the standard error for multiple variables, then you'd have to write the code above multiple times. Even if you copy paste the code and change the variable names, this process may be prone to errors. A better approach would be to make it a function. Following the syntax, we can write the standard error function as follows. 

```{r own_function}
std_error <- function(x){
  sqrt(var(x, na.rm = T) / length(x))
}
```

Here, `std_error` is the function name. It takes `x` as the argument, which in our case would be a vector. Then every time we pass a vector to this function, it will calculate the formula provided in the body. 

Now let's add the GDP of these countries, and use the `std_error()` function we just created to compute the standard deviation. 

```{r std_error}
first_df <- first_df %>%
  add_column(gdp = c(50300, 1090, 52100, 6110))

#always good to check if you wrote the function correctly
std_error(first_df$emissions) 

std_error(first_df$gdp)
```

## Importing a function

In some cases, you may write a function and save it in a different script. You can then import that script into your current script using the `source()` function.

In this example below, we first specify the model parameters (a, b, m0, etc.). Then we call the function get_delta saved in the `price_function.R` script saved in the `code` folder in my working directory using the `source()` and `here()` commands. You will notice a `get_delta()` function appear in your `Environment` tab. Then you can run the function as if you wrote it in this script. 

Other times `source()` may be helpful is when you have a "main" or "master" script that will run all the scripts in your project. For example, you might have a cleaning script, analysis script, figures script, and then a "main" script that runs all of these individual scripts. 

```{r price_function}
# assign values to model parameters 
a <- 16.21
b <- 3.50
m0 <- -0.22
m1 <- 0.03
S0 <- 2.015
H1 <- 14.38
S_bar <- 2.015
v <- c(a, b, m0, m1, S0, H1, S_bar)

# call the script that contains the `get_delta()` function. 
source(here("code", "price_function.R"))

# run the function
del <- get_delta(v)
del
```
